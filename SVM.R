library(GEOquery)
library(glmnet)
library(illuminaHumanv4.db)
library(matrixStats)
library(e1071)

#following the R script generated by GEO2R on the GSE47598 page
#fetch the data matrix from GEO.  This contains a bunch of stuff including the expression for each gene/individual.
gse <- getGEO("GSE47598", GSEMatrix = TRUE) 

#I believe this is formatting to make the gse list convertible later with the exprs function
if (length(gse) > 1) idx <- grep("GPL10558", attr(gse, "names")) else idx <- 1
gse <- gse[[idx]]

show(gse)

#This is the classification vector (0 means patient, 1 is control)
y = c(0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1)

#Convert the GSE list into a matrix (and traspose so rows are individuals (sample) and columns are genes (features).
eset <- t(exprs(gse))

rm(gse)

#coefficient of varaition
CoVar.geo = colSds(eset,cols = 1:ncol(eset))/colMeans(eset)

spats2l <- which(colnames(eset)=="ILMN_1683678")
klf6 <- which(colnames(eset)=="ILMN_1735014")
sp140 <- which(colnames(eset)=="ILMN_1703263")
rora <- which(colnames(eset)=="ILMN_2322498")


#spats2l is 6963

#eset, which is the matrix we are interested in in huge so viewing it all takes forever in R.  This just
# let me verify that the data matches the GSM files
show(eset[,c(spats2l,klf6,sp140,rora)])
show(CoVar.geo[,c(spats2l,klf6,sp140,rora)])

#train an SVM
x <- eset
x[is.na(x)]=0
train=data.frame(x,y)
my_svm <- svm(y ~ x , train)
pred <- predict(my_svm, train)

summary(my_svm)

svm_error <- sqrt(mean((y - pred)^2)) 
svm_error

#Tuning the SVM (This takes a very long time)
svm_tune <- tune(svm, array(data = y) ~ x, data = train, ranges = list(epsilon = seq(0,1,0.01), cost = 2^(2:9)))
print(svm_tune)

#best svm from the Tune
best_mod <- svm_tune$best.model
best_mod_pred <- predict(best_mod, train) 

error_best_mod <- train$y - best_mod_pred 
best_mod_RMSE <- sqrt(mean(error_best_mod^2))
